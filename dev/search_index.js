var documenterSearchIndex = {"docs":
[{"location":"developers/#Package-Development","page":"Package Development","title":"Package Development","text":"","category":"section"},{"location":"developers/","page":"Package Development","title":"Package Development","text":"Pages = [\"developers.md\"]\nDepth = 3","category":"page"},{"location":"developers/","page":"Package Development","title":"Package Development","text":"This is the first package we have ever developed. This means that it will hopefully improve significantly over time, but also that any help, experiences and advice would be greatly appreciated.","category":"page"},{"location":"developers/","page":"Package Development","title":"Package Development","text":"Feel free to contact us over email (alexander.reimer2357@gmail.com) or open an issue on the GitHub repository.","category":"page"},{"location":"developers/#Design-Principle","page":"Package Development","title":"Design Principle","text":"","category":"section"},{"location":"developers/","page":"Package Development","title":"Package Development","text":"This package has two main goals: Firstly to make the experience for the user as simple, fast and uncomplicated as possible, and secondly make it useable in every scenario.","category":"page"},{"location":"developers/","page":"Package Development","title":"Package Development","text":"To combine these two, we decided to make this package as modular and adjustable as possible. This way, we can provide \"default\" modules, so people don't have to deal with every single aspect, while still making it possible to adjust anything if a project requires it.","category":"page"},{"location":"developers/","page":"Package Development","title":"Package Development","text":"For example, say you use an unsupported EEG or want to use a different EEG processing pipeline â€“ this way, you won't need to recode big chunks of the program for small changes.","category":"page"},{"location":"developers/#Example-workflow-ideas","page":"Package Development","title":"Example workflow ideas","text":"","category":"section"},{"location":"developers/#Gathering-data","page":"Package Development","title":"Gathering data","text":"","category":"section"},{"location":"developers/","page":"Package Development","title":"Package Development","text":"using BCIInterface\n\ndevice = Device(MCP3208(\"/dev/spidev0.0\", 8))\nexperiment = Experiment(device, \"Test\", tags = [\"test\", \"significant\"], extra_info = Dict(:delay => 2), path = \"mydata/\")\nstates = [:left, :middle, :right]\nwhile true\n    for state in states\n        # Make testperson think of the $state side\n        sleep(2)\n        gather_data(device, \"data/test\", Seconds(10), tags = [state])\n    end\nend\nsave_data(experiment)","category":"page"},{"location":"developers/#Processing-data","page":"Package Development","title":"Processing data","text":"","category":"section"},{"location":"developers/","page":"Package Development","title":"Package Development","text":"data = load_data(\"Test\", :raw, path = \"mydata/\")\ndata_handler = DataHandler(\"Standard\", StandardFFT())\nprocessed_data = process_all(data, data_handler)\nsave_data(processed_data)","category":"page"},{"location":"developers/#Training-on-data","page":"Package Development","title":"Training on data","text":"","category":"section"},{"location":"developers/","page":"Package Development","title":"Package Development","text":"using BCIInterface\n\ndata = load_data(\"/data/test\")\nai = create_model(StandardOne(), data)\nai.max_accuracy = 0.9\ntrain!(ai, 100)","category":"page"},{"location":"developers/#Filtering-data","page":"Package Development","title":"Filtering data","text":"","category":"section"},{"location":"developers/","page":"Package Development","title":"Package Development","text":"using BCIInterface\n\nfunction myfilter(extra_info::Dict)::Bool\n    if haskey(extra_info, :delay) && extra_info[:delay] < 3\n        return true\n    end\n    return false\nend\ndata_filter = DataFilter(\n    include_tags = [[\"test\"], [\"significant\"]], \n    exclude_tags = [\"insignificant\"], \n    extra_info_filter = myfilter\n)\n\ndata = load_data(\"/data/test\", filter = data_filter)","category":"page"},{"location":"developers/#Creating-custom-models","page":"Package Development","title":"Creating custom models","text":"","category":"section"},{"location":"developers/","page":"Package Development","title":"Package Development","text":"using BCIInterface\n\ndata = load_data(\"/data/test\")\noutputs = [\n    (:left => [1.0, 1.0, 0.0, 0.0]),\n    (:none => [1.0, 0.0, 1.0, 0.0]),\n    (:right => [1.0, 0.0, 0.0, 1.0]),\n] # This seems very sensible...\nset_outputs!(data, outputs)\n\n\"\"\"\nMy own custom model. It's surely big enough to do any task!\n\"\"\"\nfunction my_own_model(input_shape, output_shape)\n    return @autosize (input_shape...) Chain(\n        Conv((3, 1), _ => 64),\n        flatten,\n        Dense(_, 100),\n        Dense(100, output_shape)\n    )\nend\n\nai = create_model(DefaultOne(), data, struct_constructer = my_own_model)\nai.max_accuracy = 0.9\ntrain!(ai, 100)","category":"page"},{"location":"developers/","page":"Package Development","title":"Package Development","text":"See https://fluxml.ai/Flux.jl/stable/outputsize/.","category":"page"},{"location":"developers/#Documentation","page":"Package Development","title":"Documentation","text":"","category":"section"},{"location":"developers/","page":"Package Development","title":"Package Development","text":"To preview the documentation locally before pushing to GitHub, use previewDocs.sh (Linux) or manually execute","category":"page"},{"location":"developers/","page":"Package Development","title":"Package Development","text":"`julia --project=docs -ie 'using BCIInterface, LiveServer; servedocs()'`","category":"page"},{"location":"supported_boards/#Supported-Boards","page":"Supported Boards","title":"Supported Boards","text":"","category":"section"},{"location":"supported_boards/#OpenBCI-GUI","page":"Supported Boards","title":"OpenBCI GUI","text":"","category":"section"},{"location":"supported_boards/","page":"Supported Boards","title":"Supported Boards","text":"You can use the OpenBCI GUI to get EEG data.","category":"page"},{"location":"supported_boards/","page":"Supported Boards","title":"Supported Boards","text":"You need to do the following steps in the GUI:","category":"page"},{"location":"supported_boards/","page":"Supported Boards","title":"Supported Boards","text":"Create a stream in the GUI by connecting your OpenBCI board, streaming from a file, using a synthetic stream, ...\nOpen the \"Networking\" widget.\nChange the protocol to \"LSL\" in the top right corner\nSet the data type in Stream 1 to \"FFT\"\nEnable \"Filter\" if you want\nClick on \"Start LSL Stream\"\nClick on \"Start Data Stream\" in the top left","category":"page"},{"location":"supported_boards/","page":"Supported Boards","title":"Supported Boards","text":"Now, you can create the Board object responsible for receiving the data in Julia using","category":"page"},{"location":"supported_boards/","page":"Supported Boards","title":"Supported Boards","text":"board = GanglionGUI(NUM_CHANNELS)","category":"page"},{"location":"supported_boards/","page":"Supported Boards","title":"Supported Boards","text":"where NUM_CHANNELS exactly equals the number of channels the data source connected to the GUI has.","category":"page"},{"location":"supported_boards/#MCP3208","page":"Supported Boards","title":"MCP3208","text":"","category":"section"},{"location":"supported_boards/","page":"Supported Boards","title":"Supported Boards","text":"You can build an EEG yourself by connecting electrodes to an Analogue Digtital Converter, as described in our project paper.  After the setup has been tested and optimised, building instructions and details will be published here.","category":"page"},{"location":"supported_boards/","page":"Supported Boards","title":"Supported Boards","text":"The software interface for it has already been imlemented; it relies on the DAC being a MCP3208. It hasn't been tested online, however.","category":"page"},{"location":"supported_boards/","page":"Supported Boards","title":"Supported Boards","text":"It can be used with","category":"page"},{"location":"supported_boards/","page":"Supported Boards","title":"Supported Boards","text":"board = MCP3208(NUM_CHANNELS)","category":"page"},{"location":"supported_boards/","page":"Supported Boards","title":"Supported Boards","text":"Or if you don't have a physical one, it can be \"simulated\" (voltage is always 0) with","category":"page"},{"location":"supported_boards/","page":"Supported Boards","title":"Supported Boards","text":"board = MCP3208(NUM_CHANNELS, online = false)","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = BCIInterface","category":"page"},{"location":"#BCIInterface","page":"Home","title":"BCIInterface","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for BCIInterface.","category":"page"},{"location":"","page":"Home","title":"Home","text":"WARNING: This package is currently undergoing large changes and refactoring, meaning the documentation may be out of date and the current development branch (\"refactor\") isn't finished yet.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can install this package with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url=\"https://github.com/AR102/Interpreting-EEG-with-AI\", rev=\"refactor\")","category":"page"},{"location":"#Basic-Usage","page":"Home","title":"Basic Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Include the package in your code with","category":"page"},{"location":"","page":"Home","title":"Home","text":"using BCIInterface","category":"page"},{"location":"","page":"Home","title":"Home","text":"To start collecting EEG data, first create an EEGBoard using the instructions in Supported Boards.","category":"page"},{"location":"","page":"Home","title":"Home","text":"An offline example for trying out the rest of the framework would be","category":"page"},{"location":"","page":"Home","title":"Home","text":"board = MCP3208(\"UselessBoard\", 8, online = false)\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then create an Experiment](@ref) with it:","category":"page"},{"location":"","page":"Home","title":"Home","text":"experiment = Experiment(board, \"NameOfMyExperiment\")\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now, say you want to later let an AI predict what colour a test person is thinking of. For this, you want the AI to classify the data using three categories: The person thinking of red, blue and yellow.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A possible setup would be to first make the test person think of red for 5 seconds (by telling them to or showing it on a screen) and start gathering data at the same time using gather_data!","category":"page"},{"location":"","page":"Home","title":"Home","text":"gather_data!(experiment, 5, tags=[:red])","category":"page"},{"location":"","page":"Home","title":"Home","text":"gather_data!(experiment, 0.3, tags=[:red], autosave = false) # hide\ngather_data!(experiment, 0.3, tags=[:yellow], autosave = false) # hide\ngather_data!(experiment, 0.3, tags=[:blue], autosave = false) # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, you repeat the same for yellow and blue, replacing [:red] by [:yellow] and [:blue] respectively.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To access the data, you can either use the Experiment object if you're still in the same session","category":"page"},{"location":"","page":"Home","title":"Home","text":"data = experiment.data","category":"page"},{"location":"","page":"Home","title":"Home","text":"Or you can load it from the file where it should have been automatically saved:","category":"page"},{"location":"","page":"Home","title":"Home","text":"data = load_data(\"NameOfMyExperiment\", \"RawData\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now you can start to train an AI using your collected data.","category":"page"},{"location":"","page":"Home","title":"Home","text":"First, you need to create a ModelData object. This stores the data in a format usable by an artificial neural network.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In this format, every category of inputs that we want to classify is assigned an output which the model should return whenever it recognizes this category.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is done via a Dict where each key is the label of all inputs that belong into one category and its value the output.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In our case, this could be something like","category":"page"},{"location":"","page":"Home","title":"Home","text":"outputs = Dict(\n    :red => [1.0, 0.0, 0.0],\n    :yellow => [0.0, 1.0, 0.0],\n    :blue => [0.0, 0.0, 1.0]\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"And now to create the ModelData object:","category":"page"},{"location":"","page":"Home","title":"Home","text":"modeldata = ModelData(data, outputs)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now you can create a Model (neural network) by using create_model:","category":"page"},{"location":"","page":"Home","title":"Home","text":"model = create_model(modeldata)","category":"page"},{"location":"","page":"Home","title":"Home","text":"To apply this model to some inputs:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# take first 100 samples from modeldata\nsample = modeldata.dataloader.data.inputs[:, :, 1:100]\n# calculate results, should be 3x100 (3 outputs, 100 samples)\nmodel(sample)","category":"page"},{"location":"","page":"Home","title":"Home","text":"To train the model, use train!:","category":"page"},{"location":"","page":"Home","title":"Home","text":"train!(model, modeldata, epochs=5)","category":"page"},{"location":"bci/#Creating,-managing-and-using-AI","page":"Creating, managing and using AI","title":"Creating, managing and using AI","text":"","category":"section"},{"location":"API/#Function-and-Type-Documentation","page":"Function & Type Documentation","title":"Function & Type Documentation","text":"","category":"section"},{"location":"API/#Index","page":"Function & Type Documentation","title":"Index","text":"","category":"section"},{"location":"API/","page":"Function & Type Documentation","title":"Function & Type Documentation","text":"Modules = [BCIInterface]","category":"page"},{"location":"API/#Documentation","page":"Function & Type Documentation","title":"Documentation","text":"","category":"section"},{"location":"API/","page":"Function & Type Documentation","title":"Function & Type Documentation","text":"Modules = [BCIInterface]","category":"page"},{"location":"API/#BCIInterface.AbstractDataDescriptor","page":"Function & Type Documentation","title":"BCIInterface.AbstractDataDescriptor","text":"Abstract type containing data descriptors.\n\nData is processed and trained on differently depending on the data descriptor. If you store or use your data in a format which doesn't have a data descriptor yet, you will need to define your own and overload the following functions:\n\ncreate_data(name::String, data_desc::MyDataDescriptor)\n\nget_inputshape(data_desc::MyDataDescriptor)\n\ninputarray(data_descriptor::MyDataDescriptor, num_samples::Int)\n\nrow2inputs(data_descriptor::MyDataDescriptor, row::Vector)\n\n\n\n\n\n","category":"type"},{"location":"API/#BCIInterface.AbstractDataProcessor","page":"Function & Type Documentation","title":"BCIInterface.AbstractDataProcessor","text":"Abstract class containing data processors.\n\nDefined data processors:\n\nStandardProcessor: The standard processors with preset arguments and functions, for details see StandardProcessor.\n\n\n\n\n\n","category":"type"},{"location":"API/#BCIInterface.Data-Tuple{String, BCIInterface.EEGBoard}","page":"Function & Type Documentation","title":"BCIInterface.Data","text":"Data(name::String, board::EEGBoard; dir=\"data/\")\n\nCreate Data-Object which fits given board (raw data, fft data, etc.).\n\n\n\n\n\n","category":"method"},{"location":"API/#BCIInterface.Data-Tuple{String, BCIInterface.FFTDataDescriptor}","page":"Function & Type Documentation","title":"BCIInterface.Data","text":"Data(name::String, data_desc::FFTDataDescriptor; dir=\"data/\")\n\nCreate new Data-Object for FFT data.\n\n\n\n\n\n","category":"method"},{"location":"API/#BCIInterface.Data-Tuple{String, BCIInterface.RawDataDescriptor}","page":"Function & Type Documentation","title":"BCIInterface.Data","text":"Data(name::String, data_desc::RawDataDescriptor; dir = \"data/\")\n\nCreate new Data-Object for raw data (MCP3208).\n\n\n\n\n\n","category":"method"},{"location":"API/#BCIInterface.DataHandler-Tuple{BCIInterface.AbstractDataProcessor, Any}","page":"Function & Type Documentation","title":"BCIInterface.DataHandler","text":"DataHandler(data_processor::DataProcessor, data_io::DataIO; cases=nothing,\nname=nothing, max_freq=nothing)\n\nCreate a DataHandler instance. cases, name and max_freq are automatically determined by data saved at path if they are nothing.\n\nExample:\n\ndata_io = DataIO(\"data/test\", states)\ndata_handler = DataHandler(data_io, StandardFFT())\n\n\n\n\n\n","category":"method"},{"location":"API/#BCIInterface.EEGBoard","page":"Function & Type Documentation","title":"BCIInterface.EEGBoard","text":"Supertpye of all EEG boards.\n\nWhen creating your own EEG board, you should make it a subtype of AbstractEEGBoard with\n\nstruct MyBoard <: AbstractEEGBoard\n    ...\nend\n\n\n\n\n\n","category":"type"},{"location":"API/#BCIInterface.Experiment-Tuple{BCIInterface.EEGBoard, String}","page":"Function & Type Documentation","title":"BCIInterface.Experiment","text":"Experiment(board::EEGBoard, name::String; tags::Array=[],\nextra_info::Dict= Dict(), path::String=\"data/\", load_previous::Bool=false)\n\nname: Name of the experiment (e.g. \"BlinkDetection\").\n\ntags: Tags which will be applied to all data gathered with this Experiment.\n\npath: To top-level of data directory (e.g. \"data/\"). If empty, files can't be saved.\n\nTODO: descs for keywords\n\n\n\n\n\n","category":"method"},{"location":"API/#BCIInterface.FFTDataDescriptor-Tuple{Int64, Int64}","page":"Function & Type Documentation","title":"BCIInterface.FFTDataDescriptor","text":"FFTDataDescriptor(num_channels::Int, max_freq::Int)\n\nData descriptor for FFT data in the format of a 2D-Array per sample, with the first dimension corresponding to the frequncies from 1 to maxfreq and the seconds dimension corresponding to the channels from 1 to numchannels.\n\n\n\n\n\n","category":"method"},{"location":"API/#BCIInterface.MCP3208-Tuple{String, Int64}","page":"Function & Type Documentation","title":"BCIInterface.MCP3208","text":"MCP3208(path::String, num_channels::Int; max_speed_hz::Int=1000,\nonline=true)\n\nInitialise a MCP3208-based self-built EEG.\n\npath::String: SPI path of the device\n\nnum_channels::Int: Number of connected electrodes.\n\nmax_speed_hz::Int: 1000 by default. Tells the Raspberry Pi (or similar device) how often per second the output should be read.\n\nTODO: explain (side) effects\n\nonline::Bool: true by default; if set to false, get_voltage(...) will just return 0. This is for testing all associated functions and devices using this board without having it connected (e.g. in tests).\n\n\n\n\n\n","category":"method"},{"location":"API/#BCIInterface.Model","page":"Function & Type Documentation","title":"BCIInterface.Model","text":"Model(network::Flux.Chain, epochs::Int, savedir::String, modelname::String)\n\nCreate a Model object with four fields:\n\nnetwork: The neural network in the form of a Flux Chain.\n\nepochs: The number of epochs the model has already been trained for.\n\nsavedir: The directory where the model will be saved.\n\nmodelname: The name of the subdirectory where the model will be saved.\n\n\n\n\n\n","category":"type"},{"location":"API/#BCIInterface.Model-Tuple{Any}","page":"Function & Type Documentation","title":"BCIInterface.Model","text":"(model::Model)(inputs)\n\nApply model to inputs to calculate outputs.\n\nExample:\n\nmodel(inputs)\n\n\n\n\n\n","category":"method"},{"location":"API/#BCIInterface.ModelData","page":"Function & Type Documentation","title":"BCIInterface.ModelData","text":"ModelData\n\nA type for storing data in a neural network friendly way.\n\nFields:\n\ndataloader::DataLoader: Store the data in a Flux.DataLoader. Data can be accessed with dataloader.data, returning a named tuple (inputs=..., outputs=...). Both fields of the tuple are multidimensional arrays with the last dimension corresponding to the sample.\ntag2output: see outputs described in the constructor ModelData.\ndatadescriptor: The AbstractDataDescriptor of the original data.\n\n\n\n\n\n","category":"type"},{"location":"API/#BCIInterface.ModelData-Tuple{Data, Dict}","page":"Function & Type Documentation","title":"BCIInterface.ModelData","text":"ModelData(data::Data, outputs::Dict; batchsize=5, shuffle=true)\n\nCreate ModelData suitable for use with neural networks.\n\ndata: A [Data] object storing the EEG data.\n\ntag2output: Dictionary; each key is a tag (saved in data) with the value representing the output the model should give for that tag.\n\nExample:\n\n# classification:\ndata_class = load_data(\"data/Emotions\", \"RawData\")\ntag2output_class = Dict(\n    :scared => [1.0, 0.0, 0.0],\n    :angry => [0.0, 1.0, 0.0],\n    :happy => [0.0, 0.0, 1.0]\n)\nmodeldata_class = ModelData(data, tag2output_class)\n# regression:\ndata_reg = load_data(\"data/Concentration\", \"RawData\")\ntag2output_reg = Dict(\n    :rest => [0.0],\n    :task1 => [0.2],\n    :task2 => [0.7],\n    :task3 => [1.0]\n)\nmodeldata_reg = ModelData(data, tag2output_reg)\n\n\n\n\n\n","category":"method"},{"location":"API/#BCIInterface.RawDataDescriptor-Tuple{Int64}","page":"Function & Type Documentation","title":"BCIInterface.RawDataDescriptor","text":"RawDataDescriptor(num_channels::Int)\n\nData descriptor for raw data in the format of a 1D-Array per sample, with each channels voltage in a row.\n\nnum_channels::Int: Number of channels the data has (= width of the row).\n\n\n\n\n\n","category":"method"},{"location":"API/#BCIInterface.StandardProcessor","page":"Function & Type Documentation","title":"BCIInterface.StandardProcessor","text":"Standard configuration for processing EEG data. It uses a preset of functions and options and may not work for you.\n\nCreate with Standard.\n\n\n\n\n\n","category":"type"},{"location":"API/#BCIInterface.Standard-Tuple{}","page":"Function & Type Documentation","title":"BCIInterface.Standard","text":"Standard()::StandardProcessor\n\nCreate standard configuration for processing EEG data. See StandardProcessor for more details.\n\n\n\n\n\n","category":"method"},{"location":"API/#BCIInterface._read_metadata-Tuple{Any}","page":"Function & Type Documentation","title":"BCIInterface._read_metadata","text":"_read_metadata(filepath)\n\nInternal method used for reading from file; in function to make later switch of file format easier.\n\n\n\n\n\n","category":"method"},{"location":"API/#BCIInterface._write_metadata-Tuple{Any, BCIInterface.Metadata}","page":"Function & Type Documentation","title":"BCIInterface._write_metadata","text":"_write_metadata(filepath, metadata::Metadata)\n\nInternal method used for writing to file; in function to make later switch of file format easier.\n\n\n\n\n\n","category":"method"},{"location":"API/#BCIInterface.clear!-Tuple{Data}","page":"Function & Type Documentation","title":"BCIInterface.clear!","text":"clear!(data::Data)\n\nDelete all saved data.\n\n\n\n\n\n","category":"method"},{"location":"API/#BCIInterface.clear!-Tuple{Experiment}","page":"Function & Type Documentation","title":"BCIInterface.clear!","text":"clear!(experiment::Experiment)\n\nDelete all saved data.\n\n\n\n\n\n","category":"method"},{"location":"API/#BCIInterface.create_model-Tuple{ModelData}","page":"Function & Type Documentation","title":"BCIInterface.create_model","text":"create_model(data::ModelData; network_constructor::Function=standard_network)\n\nCreate a model with a neural network for classifying / regressing data.\n\nnetwork_constructor: The given function is given three arguments: the input shape and output shape of the data, each represented by a tuple, and the data descriptor of type DataDescriptor.\n\nThe default network_constructor if not supplied is standard_network.\n\n\n\n\n\n","category":"method"},{"location":"API/#BCIInterface.createpath-Tuple{String}","page":"Function & Type Documentation","title":"BCIInterface.createpath","text":"create_path(path::String)\n\nCreate necessary folders and file if they don't exist yet, so that isdir(path) or isfile(path) returns true depending on whether path points to a folder or a file.\n\n\n\n\n\n","category":"method"},{"location":"API/#BCIInterface.datetime-Tuple{Number}","page":"Function & Type Documentation","title":"BCIInterface.datetime","text":"datetime(seconds_since_epoch)\n\nConvert seconds since unix epoch into a DateTime object.\n\n\n\n\n\n","category":"method"},{"location":"API/#BCIInterface.element-Tuple{Dict}","page":"Function & Type Documentation","title":"BCIInterface.element","text":"element(dict::Dict)\n\nReturn the value of the first key-value pair of dict.\n\n\n\n\n\n","category":"method"},{"location":"API/#BCIInterface.gather_data!-Tuple{Experiment, Number}","page":"Function & Type Documentation","title":"BCIInterface.gather_data!","text":"gather_data!(experiment::Experiment, runtime::Number; tags::Array=[],\nextra_info::Dict=Dict())\n\nGather raw EEG data.\n\nruntime: Runtime in seconds.\n\nOptional arguments:\n\ntags: Tags to add to every data point on top of tags given to Experiment\n\nextra_info: Extra info to add to every data point on top of extra info given to Experiment\n\n\n\n\n\n","category":"method"},{"location":"API/#BCIInterface.get_most_recent-Tuple{String}","page":"Function & Type Documentation","title":"BCIInterface.get_most_recent","text":"get_most_recent(dir_path::String)::String\n\nReturn the path of the file with the most recent date in the file name. Only works on files where the data starts at the seventh character and has the format YYYY-mm-dd_HH-MM-SS. ````\n\n\n\n\n\n","category":"method"},{"location":"API/#BCIInterface.get_sample!-Tuple{BCIInterface.EEGBoard}","page":"Function & Type Documentation","title":"BCIInterface.get_sample!","text":"get_sample!(board::EEGBoard)\n\nUpdates board.sample to new data from board.\n\n\n\n\n\n","category":"method"},{"location":"API/#BCIInterface.get_timestr-Tuple{}","page":"Function & Type Documentation","title":"BCIInterface.get_timestr","text":"get_timestr()::String\n\nReturn the current time as a string of the form YYYY-mm-dd_HH-MM-SS.\n\nUsed for file and folder names.\n\n\n\n\n\n","category":"method"},{"location":"API/#BCIInterface.get_voltage-Tuple{MCP3208, Int64}","page":"Function & Type Documentation","title":"BCIInterface.get_voltage","text":"get_voltage(board::MCP3208, channel::Int)\n\nRead digital output of the ADC on channel channel.\n\nIf MCP3208 was given online=false at creation, return 0 instead.\n\n\n\n\n\n","category":"method"},{"location":"API/#BCIInterface.iscompatible-Tuple{DataFrames.DataFrame, Union{Nothing, BCIInterface.Metadata}}","page":"Function & Type Documentation","title":"BCIInterface.iscompatible","text":"is_compat(df::DataFrame, metadata::Union{Metadata, Nothing})\n\nCheck if df is \"compatible\" with metadata.\n\nIf metadata is nothing, then return true (for easy use with load_metadata which returns nothing when no metadata is defined)\n\n\n\n\n\n","category":"method"},{"location":"API/#BCIInterface.load_model-Tuple{String}","page":"Function & Type Documentation","title":"BCIInterface.load_model","text":"load_model(path::String)::Model\n\nLoad the model saved in file at path.\n\nIf path is a directory, use get_most_recent to find file with the most recent time in the file name.\n\n\n\n\n\n","category":"method"},{"location":"API/#BCIInterface.parse_modelname-Tuple{String}","page":"Function & Type Documentation","title":"BCIInterface.parse_modelname","text":"parse_modelname(modelname::String)\n\nParse all special characters in given string.\n\nSpecial characters:\n\n*t -> replace with current date and time (see get_timestr).\n\nExample:\n\njulia> parse_modelname(\"mymodel_*t_blue\")\n\"mymodel_2023-02-04_14-17-51_blue\"\n\n\n\n\n\n","category":"method"},{"location":"API/#BCIInterface.process-Tuple{BCIInterface.EEGBoard, BCIInterface.StandardProcessor}","page":"Function & Type Documentation","title":"BCIInterface.process","text":"process(board::EEGBoard, processor::StandardProcessor)\n\nTODO: Processing\n\n1. Artifacts Removal\n2. Data Filtering\n3. Feature Extraction (FFT)\n\nAlso see this, page 2529.\n\n\n\n\n\n","category":"method"},{"location":"API/#BCIInterface.save","page":"Function & Type Documentation","title":"BCIInterface.save","text":"save(model::Model, path::String, overwrite=false)\n\nSave given model at path.\n\nIf path is a directory, save the model there as a file with the current time as filename.\n\nIf overwrite=false (default), throw an error if the file at path already exists.\n\n\n\n\n\n","category":"function"},{"location":"API/#BCIInterface.save-Tuple{BCIInterface.Model}","page":"Function & Type Documentation","title":"BCIInterface.save","text":"save(model::Model)\n\nSave the model in the folder model.savedir, in the subfolder model.modelname with the filename \"modelcurrentTime\", where currentTime is the current time as given by [`gettimestr`](@ref).\n\n\n\n\n\n","category":"method"},{"location":"API/#BCIInterface.save-Tuple{Data, DataFrames.DataFrame}","page":"Function & Type Documentation","title":"BCIInterface.save","text":"save(data::Data, df::DataFrame; name=\"data\", checkmeta=true, updatemeta=true,\n    overwrite=false)\n\nSave given df. Folder is determined by data (data.dir and data.name), file name by name.\n\nKeywords\n\ncheckmeta=true: Load and check Metadata saved at the location for compatibility if it already exists.\nupdatemeta=true: Save the updated Metadata.\noverwrite=false: When true, overwrite already existing data and meta data.\n\n\n\n\n\n","category":"method"},{"location":"API/#BCIInterface.save-Tuple{Data}","page":"Function & Type Documentation","title":"BCIInterface.save","text":"save(data::Data; checkmeta=true, updatemeta=true, overwrite=false, repeat=false)\n\nSave given data. Folder is determined by data (data.dir * \"/\" * data.name), file name by name.\n\n\n\n\n\n","category":"method"},{"location":"API/#BCIInterface.standard_network-Tuple{Any, Any, Any}","page":"Function & Type Documentation","title":"BCIInterface.standard_network","text":"standard_network(inputshape, outputshape, datadescriptor)::Flux.Chain\n\nChoose and create a neural network based on the given inputshape, outputsshape and datadescriptor.\n\nThese networks are what we're currently using and may not be ideal for you.\n\nThere are only networks predefined for RawDataDescriptor and FFTDataDescriptor with a 1d output.\n\n\n\n\n\n","category":"method"},{"location":"API/#BCIInterface.standard_trainingparameters-Tuple{}","page":"Function & Type Documentation","title":"BCIInterface.standard_trainingparameters","text":"standard_trainingparameters()\n\nReturns a TrainingParameters object with all fields populated with (hopefully) reasonable defaults.\n\n\n\n\n\n","category":"method"},{"location":"API/#BCIInterface.testmode!-Tuple{BCIInterface.Model}","page":"Function & Type Documentation","title":"BCIInterface.testmode!","text":"trainmode!(model::Model)\n\nSome layers of neural networks behave differently when training and when testing the network (e.g. Dropout).\n\nUse this to set the model into testing mode (Dropout etc. will not be executed.)\n\nUse trainmode! for putting the model into training mode.\n\n\n\n\n\n","category":"method"},{"location":"API/#BCIInterface.train!-Tuple{BCIInterface.Model, ModelData}","page":"Function & Type Documentation","title":"BCIInterface.train!","text":"train!(model::Model, data::ModelData;\nparams::TrainingParameters=standard_trainingparameters(), kws...)\n\nTrain the given model using given data as training data.\n\nTo adjust training parameters, you can either create your own TrainingParameters object and pass it as params=myparams or adjust the default TrainingParameters object (given by standard_trainingparameters) by passing key-value pairs like epochs=3, Î·=0.02, autosave=3.\n\nExamples:\n\ntrain!(model, modeldata, epochs = 20, show_progress = false, opt_rule = GradientDescent)\n\nmyparams = TrainingParameters(0.02, 20, x -> x, cpu, Flux.logitcrossentropy,\n        GradientDescent, [], false, 5)\n\ntrain!(model, modeldata, params = myparams)\n\n\n\n\n\n","category":"method"},{"location":"API/#BCIInterface.trainmode!-Tuple{BCIInterface.Model}","page":"Function & Type Documentation","title":"BCIInterface.trainmode!","text":"trainmode!(model::Model)\n\nSome layers of neural networks behave differently when training and when testing the network (e.g. Dropout).\n\nUse this to set the model into training mode (Dropout etc. will be executed.)\n\nUse testmode! for putting the model into testing mode.\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.:==-Tuple{BCIInterface.Model, BCIInterface.Model}","page":"Function & Type Documentation","title":"Base.:==","text":"Base.:(==)(a::Model, b::Model)\n\nCheck two Models for equality.\n\nExample:\n\na::Model\nb::Model\n\nif a == b\n    println(\"both models are the same!\")\nend\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.:==-Tuple{Flux.Chain, Flux.Chain}","page":"Function & Type Documentation","title":"Base.:==","text":"Base.:(==)(a::Flux.Chain, b::Flux.Chain)\n\nCheck two Flux Chains for equality. Returns true if\n\nnumber and types of layers are the same\nall fields (weight, bias, etc.) of all layers are the same\n\n\n\n\n\n","category":"method"}]
}
